# Georgia Flow – მეგობრების სისტემა + Realtime Messaging

## მიზანი
- სოციალური ქსელი აპის შიგნით: მეგობრების დამატება, წაშლა, პირადი მესიჯები
- Realtime ჩატი Supabase Realtime-ით (websocket)
- უსაფრთხოება: მესიჯები მხოლოდ მეგობრებს შორის (ან მოთხოვნის შემდეგ)
- მრავალენოვანი ინტერფეისი

## 1. მეგობრების სისტემა (Friends System)

### Supabase Tables (სქემა)
```sql
-- მეგობრობის junction table (მრავალ-მრავალ ურთიერთობა)
create table user_friends (
  id bigint generated by default as identity primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  friend_id uuid references profiles(id) on delete cascade not null,
  status text default 'pending' check (status in ('pending', 'accepted', 'rejected')), -- pending = მოთხოვნა გაგზავნილი
  requested_by uuid references profiles(id),
  created_at timestamptz default now(),
  unique(user_id, friend_id)
);

-- RLS პოლისები (მხოლოდ საკუთარი მეგობრები ჩანს)
alter table user_friends enable row level security;
create policy "Users can view their own friends" on user_friends for select
  using (auth.uid() = user_id or auth.uid() = friend_id);
create policy "Users can send friend requests" on user_friends for insert
  with check (auth.uid() = user_id);
create policy "Users can update/accept their requests" on user_friends for update
  using (auth.uid() = friend_id and status = 'pending');
UI / ფუნქციები

მეგობრის ძებნა და დამატება:
პროფილის გვერდზე ან ცალკე /friends გვერდზე: search bar (username-ით ძებნა)
შედეგები: ავატარი + username + "დამატება" ღილაკი (ნარინჯისფერი)
კლიკზე: Supabase insert user_friends-ში (status: 'pending', requested_by: current_user)
თუ უკვე მეგობარია ან pending – ღილაკი გამორთულია ("მოთხოვნა გაგზავნილია")

მოთხოვნების მენეჯმენტი (Notifications ან Friends ტაბში)
"მეგობრობის მოთხოვნები" სექცია: ლისტი pending requests-ის
თითო მოთხოვნა: ავატარი, username, "მიღება" (მწვანე) / "უარყოფა" (წითელი)
მიღებაზე: update status to 'accepted'
უარყოფაზე: update to 'rejected' ან delete row

მეგობრების ლისტი:
პროფილის Friends ტაბში: grid ან list
თითო მეგობარი: ავატარი, username, ბოლო აქტივობა (optional), "წაშლა" (წითელი ღილაკი), "შეტყობინება" (chat icon)
წაშლაზე: delete from user_friends (both directions symmetric)

Realtime: subscribe user_friends table-ზე → ახალი მოთხოვნა ან მიღება → notification badge ან toast

2. Realtime Messaging (ჩატი)
Supabase Table (Messages)
SQLcreate table messages (
  id bigint generated by default as identity primary key,
  sender_id uuid references profiles(id) not null,
  receiver_id uuid references profiles(id) not null,
  content text,
  media_url text,  -- Supabase Storage link ფოტო/ვიდეოსთვის
  is_read boolean default false,
  created_at timestamptz default now()
);

-- RLS: მხოლოდ sender/receiver ხედავს
alter table messages enable row level security;
create policy "Users can view their messages" on messages for select
  using (auth.uid() = sender_id or auth.uid() = receiver_id);
create policy "Users can send messages" on messages for insert
  with check (auth.uid() = sender_id);
UI / ჩატის ინტერფეისი

Chat List (პროფილის Messages ტაბში ან ცალკე /messages):
ლისტი მეგობრებით: ავატარი, username, ბოლო მესიჯი + დრო, unread count badge
კლიკზე: გადადის full chat view

Full Chat View (/chat/[friend_id] ან modal):
ზედა: მეგობრის ავატარი + სახელი + back button
შუა: მესიჯების სია (bubble style)
საკუთარი მესიჯები: მარჯვნივ, მწვანე/ნარინჯისფერი bubble
მეგობრის: მარცხნივ, ღია ნაცრისფერი
დრო + is_read (double check icon)

ქვედა: input field + emoji picker + attach button (ფოტო/ვიდეო upload)
Send button (ნარინჯისფერი)
Typing indicator: "წერს..." (როცა მეგობარი ტიპავს)

ფუნქციები:
ტექსტური მესიჯები
Emoji + GIF (optional, emoji-mart ბიბლიოთეკა)
Media attach: Supabase Storage upload → insert media_url
Read receipts: update is_read on view
Realtime: supabase.channel(chat:${min(user_id, friend_id)}-${max(user_id, friend_id)}).on('postgres_changes', ...)